# Lex程序
## Lex 语法

现在大概的设定就是`lex.i`文件分为3个部分

![](./61520216石杰.assets/image-20230324151221856.png)

### Definition

分为两部分

- 在`%{ %}`中的部分直接copy到源程序
- 在`%{ %}`外的部分为定义的**Lex替换式**
  - 格式: `<name>  <translation>`
  - 例如 letter  [a-zA-Z]

### Rules

其中Rules的结构为`<reg. exp> <action>`

#### `<reg. exp>`

- 位于行头, 结束于空格

- 规则

  - **运算符**: `" \ [ ] ˆ - ? . * | ( ) $ / { } % < >` 有运算作用, 无法匹配自身. 运算符可以通过斜杠`\`转意, 从而匹配自身, 如匹配字符串时`\"(\\.|[^\\"\n])*\"`中的`\"`就可以匹配双引号`"`
  - 字母和数字匹配其本身
  - 点`.`匹配除换行符`\n`外任意操作符
  - 方括号`[ ]`中包含的一串字符被命名为一个"字符族", 字符族可以匹配:
    - 字符族中出现的字符, 如`[ab]`可以匹配a或b
    - `-`表示范围, 如`[a-c]`可以匹配 a或b或c
    - `^`表示补集, 如`[^ a-c]`可以匹配除a, b, c以外的一切字符
  - 双引号`""`内字符可以匹配其本身, 如`"+"`可以匹配加号`+`, `"."`可以匹配点号`.`
  - `\n, \t`匹配换行, tab
  - ![image-20230324154136103](./61520216石杰.assets/image-20230324154136103.png)
  - 上一部分定义的子表达式需要用花括号`{}`括起来, 如`{letter}`

- 多个匹配时
  - 长度不同: 最长匹配原则
    - 如`"/""*"(.|\n)*"*""/"`目的是匹配多行注释, 但可能结果是匹配到所有输入字符
  - 相同长度: 匹配最前面的规则

- 与通常意义的正则表达式相比缺少的特性(后续可以增加):

  - 没有简写符: `\w, \W, \d, \D, \s, \S`等, 简写符需要在**Definition**部分自行定义

  - 没有`^`和`$`标记字符串的开始与结尾

  - 没有长度匹配`{m,n}`

  - 没有最短匹配模式如`.*?`

  - 括号`()`是运算意义上的分组, 类似四则运算, 不是匹配意义上的分组

#### `<action>`

- 识别后的动作
- 与程序间的通讯变量
  - `yytext` 成果匹配的原始字符串
  - `yyleng` 匹配的字符串长度
- `;` 什么也不做
- `|` 表示与下一动作一致
- `ECHO;` 等价于`printf("%s", yytext)`

### User subroutines

任意合法的C代码, 复制到C文件中

## Regex类

### 标准(最简)正则表达式

只有字母, 数字和 $|,\ \cdot, \ ^*$运算符, 例如$a(a|b)^*cd$, 加入运算符后为$a\cdot(a|b)^*\cdot c \cdot d$

### 后缀表达式

