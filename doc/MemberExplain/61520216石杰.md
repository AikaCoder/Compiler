# Lex程序
## Lex 语法

现在大概的设定就是`lex.i`文件分为3个部分

- Definition: 在第一个%%前
- Rules: 在第一个%%和第二个%%之间
- User subroutines: 在第二个%%之后

### Definition

分为两部分

- 在`%{ %}`中的部分直接copy到源程序
- 在`%{ %}`外的部分为定义的**Lex替换式**
  - 格式: `<name>  <translation>`
  - 例如 letter  [a-zA-Z]

### Rules

其中Rules的结构为`<reg. exp> <action>`

#### `<reg. exp>`

- 位于行头, 结束于空格

- 规则

  - **运算符**: `" \ [ ] ˆ - ? . * | ( ) $ / { } % < >` 有运算作用, 无法匹配自身. 运算符可以通过斜杠`\`转意, 从而匹配自身, 如匹配字符串时`\"(\\.|[^\\"\n])*\"`中的`\"`就可以匹配双引号`"`
  - 字母和数字匹配其本身
  - 点`.`匹配除换行符`\n`外任意操作符
  - 方括号`[ ]`中包含的一串字符被命名为一个"字符族", 字符族可以匹配:
    - 字符族中出现的字符, 如`[ab]`可以匹配a或b
    - `-`表示范围, 如`[a-c]`可以匹配 a或b或c
    - `^`表示补集, 如`[^ a-c]`可以匹配除a, b, c以外的一切字符
  - 双引号`""`内字符可以匹配其本身, 如`"+"`可以匹配加号`+`, `"."`可以匹配点号`.`
    - 注意, `""`内不支持转义, 比如`"\""`或`"\t"`, 里面直接匹配其本身, 而要相匹配`"`, 只能使用`\"`
  - `\n, \t`匹配换行, tab
  - 圆括号: `()` 表示表示提高运算等级, 这里我们没有使用分组
  - 竖号`丨` 表示可选的, 与标准正则表达式语法一致, 如`a(b|c)`匹配`ab`或`ac`
  - 后置符号, 包括
    - 星号 `*`, 表示0个或更多
    - 加号 `+`, 表示1个或更多
    - 问号 `?`, 表示0个或1个
  - 上一部分定义的子表达式需要用花括号`{}`括起来, 如`{letter}`
    - 注意`{}`内也不支持转义
  - `/* */`是注释(未实现)
  - `%start, <start>`是lex状态切换(未实现)
  - `$`主要用于yacc(保留)

- 多个匹配时
  - 长度不同: 最长匹配原则
    - 如`"/""*"(.|\n)*"*""/"`目的是匹配多行注释, 但可能结果是匹配到所有输入字符
  - 相同长度: 匹配最前面的规则

- 与通常意义的正则表达式相比缺少的特性(后续可以增加):

  - 没有简写符: `\w, \W, \d, \D, \s, \S`等, 简写符需要在**Definition**部分自行定义

  - 没有`^`和`$`标记字符串的开始与结尾

  - 没有长度匹配`{m,n}`

  - 没有最短匹配模式如`.*?`

  - 括号`()`是运算意义上的分组, 类似四则运算, 不是匹配意义上的分组

#### `<action>`

- 识别后的动作
- 与程序间的通讯变量
  - `yytext` 成果匹配的原始字符串
  - `yyleng` 匹配的字符串长度
- `;` 什么也不做
- `|` 表示与下一动作一致
- `ECHO;` 等价于`printf("%s", yytext)`

### User subroutines

任意合法的C代码, 复制到C文件中

## Regex类

### 数据结构

#### 标准(最简)正则表达式

~~只有字母, 数字和 $|,\ \cdot, \ ^*$运算符, 例如$a(a|b)^*cd$, 加入运算符后为$a\cdot(a|b)^*\cdot c \cdot d$~~

讨论后决定保留+, ?, *, $\cdot$, | 共5个运算符, 对+和?的处理交由后续构建NFA类

#### 后缀表达式

(?)尝试采用栈存储结构, 存储节点形式为

### 公共方法
```java
/**
 * 初始化Regex
 * @param str 原始正则
 */
public LexRegex(String str) throws SeuCompilerException
    
/**
 * @return 得到后缀表达式列表
 */
public ArrayList<LexCharacterNode> getSuffixExpression()

/**
 * @return 得到原始正则
 */
public String getRawStr()

/**
* 得到纯字符串形式的后缀表达式
*/
public String getSuffixStr()
```

### 当前进度

- [x] 替换替代项 {digit} -> [0-9]

- [x] 范围展开 [0-9] -> (0|1|2|...|9)

- [ ] ~~重复项替换 a+ -> aa*~~

- [x] 加点 a | bc -> a | b · c

- [x] 转变为后缀形式 a | b · c -> a b|c ·

  

- 改用自动机形式实现, 

### 使用示例

```java
public static void TestRegex(){
    LexRegex.addLexRegexSubstitutions("D", "[0-9]");
    LexRegex.addLexRegexSubstitutions("L", "[a-zA-Z_]");
    LexRegex testRegex = new LexRegex("{L}({L}|\"{D}\"[{}])*");
    System.out.println(testRegex.getRawRegex());
    System.out.println(testRegex.getSimpleRegex());
    //目前结果为 [a-zA-Z_]([a-zA-Z_] | "{D}"[{}])*
}
```
### 测试
#### 测试用例设计

- 正例

  - | 说明           | 输入                       | 预期输出 |
    | -------------- | -------------------------- | -------- |
    | 用户自定义替代 | 替代关系: t -> test; a{t}b | atestb   |
    | 范围           |                            |          |
    |                |                            |          |
    |                |                            |          |

    

- 反例

#### 测试过程和结果
