# Lex程序
## Lex 语法

现在大概的设定就是`lex.i`文件分为3个部分

- Definition: 在第一个%%前
- Rules: 在第一个%%和第二个%%之间
- User subroutines: 在第二个%%之后

### Definition

分为两部分

- 在`%{ %}`中的部分直接copy到源程序
- 在`%{ %}`外的部分为定义的**Lex替换式**
  - 格式: `<name>  <translation>`
  - 例如 letter  [a-zA-Z]

### Rules

其中Rules的结构为`<reg. exp> <action>`

#### `<reg. exp>`

- 位于行头, 结束于空格

- 规则

  - **运算符**: `" \ [ ] ˆ - ? . * | ( ) $ / { } % < >` 有运算作用, 无法匹配自身. 运算符可以通过斜杠`\`转意, 从而匹配自身, 如匹配字符串时`\"(\\.|[^\\"\n])*\"`中的`\"`就可以匹配双引号`"`
  - 字母和数字匹配其本身
  - 点`.`匹配除换行符`\n`外任意操作符
  - 方括号`[ ]`中包含的一串字符被命名为一个"字符族", 字符族可以匹配:
    - 字符族中出现的字符, 如`[ab]`可以匹配a或b
    - `-`表示范围, 如`[a-c]`可以匹配 a或b或c
    - `^`表示补集, 如`[^ a-c]`可以匹配除a, b, c以外的一切字符
  - 双引号`""`内字符可以匹配其本身, 如`"+"`可以匹配加号`+`, `"."`可以匹配点号`.`
  - `\n, \t`匹配换行, tab
  - 圆括号: `()` 表示表示提高运算等级, 这里我们没有使用分组
  - 竖号`丨` 表示可选的, 与标准正则表达式语法一致, 如`a(b|c)`匹配`ab`或`ac`
  - 后置符号, 包括
    - 星号 `*`, 表示0个或更多
    - 加号 `+`, 表示1个或更多
    - 问号 `?`, 表示0个或1个
  - 上一部分定义的子表达式需要用花括号`{}`括起来, 如`{letter}`

- 多个匹配时
  - 长度不同: 最长匹配原则
    - 如`"/""*"(.|\n)*"*""/"`目的是匹配多行注释, 但可能结果是匹配到所有输入字符
  - 相同长度: 匹配最前面的规则

- 与通常意义的正则表达式相比缺少的特性(后续可以增加):

  - 没有简写符: `\w, \W, \d, \D, \s, \S`等, 简写符需要在**Definition**部分自行定义

  - 没有`^`和`$`标记字符串的开始与结尾

  - 没有长度匹配`{m,n}`

  - 没有最短匹配模式如`.*?`

  - 括号`()`是运算意义上的分组, 类似四则运算, 不是匹配意义上的分组

#### `<action>`

- 识别后的动作
- 与程序间的通讯变量
  - `yytext` 成果匹配的原始字符串
  - `yyleng` 匹配的字符串长度
- `;` 什么也不做
- `|` 表示与下一动作一致
- `ECHO;` 等价于`printf("%s", yytext)`

### User subroutines

任意合法的C代码, 复制到C文件中

## Regex类

### 数据结构

#### 标准(最简)正则表达式

~~只有字母, 数字和 $|,\ \cdot, \ ^*$运算符, 例如$a(a|b)^*cd$, 加入运算符后为$a\cdot(a|b)^*\cdot c \cdot d$~~

讨论后决定保留+, ?, *, $\cdot$, | 共5个运算符, 对+和?的处理交由后续构建NFA类

#### 后缀表达式

~~(?)尝试采用栈存储结构, 存储节点形式为~~

~~public class ExpressionNode {
~~    boolean isLexRegexOperator;
~~    LexRegexOperator operator;
~~    String content;
~~}~~

讨论后决定先按字符串形式返回

### 公共方法

```java
/**
 * 将在第一部分定义的, 用于简化替代的正则表达式添加到LexRegex类, 应该在调用构造函数之前使用
 * 例如:
 *  digital   [0-9]
 *  H         [a-fA-F0-9]
 * @param name 用于替换的别名, 例如 digital
 * @param regexStr 对应的正则表达式, 例如[0-9]
 */
public static void addLexRegexSubstitutions(String name, String regexStr)
```

```java
/**
 * 构造函数, 放入的是原始正则
 * @param rawRegex 原始正则表达式
 */
public LexRegex(String rawRegex)
```

```java
/**
 * @return 原正则表达式
 */
public String getRawRegex()
```

```java
/**
 * 得到表最简表达式的后缀形式, 栈形式存储, 如 (a|b)·(b·c)* --> ab|bc·*· 栈顶是a
 * @return 后缀表达式
 */
//public Stack<ExpressionNode> getExpressionNodeStack() 改为直接返回字符串
Public String getSuffixExpression();
```

```java
/**
 * 只有优先级为 `*` > `·` > `|` 的三个运算符, 以及括号()
 * 例如 a·b*·(c|d)·e
 * @return 最简正则表达式
 */
public String getSimpleRegex()
```

### 当前进度

- [x] 替换替代项 {digit} -> [0-9]
- [ ] 范围展开 [0-9] -> (0|1|2|...|9)
- [ ] ~~重复项替换 a+ -> aa*~~
- [ ] 加点 a | bc -> a | b · c
- [ ] 转变为后缀形式 a | b · c -> a b|c ·

### 示例

```java
public static void TestRegex(){
    LexRegex.addLexRegexSubstitutions("D", "[0-9]");
    LexRegex.addLexRegexSubstitutions("L", "[a-zA-Z_]");
    LexRegex testRegex = new LexRegex("{L}({L}|\"{D}\"[{}])*");
    System.out.println(testRegex.getRawRegex());
    System.out.println(testRegex.getSimpleRegex());
    //目前结果为 [a-zA-Z_]([a-zA-Z_] | "{D}"[{}])*
}
```

